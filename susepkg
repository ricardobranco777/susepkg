#!/usr/bin/env python3
"""
Show SUSE package versions
"""

import argparse
import fnmatch
import logging
import platform
import re
import sys
from collections import UserString
from concurrent.futures import ThreadPoolExecutor
from datetime import timedelta
from functools import cache, total_ordering
from urllib.parse import urlencode

import rpm  # type: ignore
from requests.exceptions import RequestException

# Creates cache.sqlite
from requests_cache import CachedSession

# Adapted from https://requests-cache.readthedocs.io/en/stable/
session = CachedSession(
    "susepkg.cache",
    use_cache_dir=True,  # Save files in the default user cache dir
    cache_control=True,  # Use Cache-Control response headers for expiration
    expire_after=timedelta(days=1),  # Expire responses after one day
)


TIMEOUT = 10
VERSION = "0.7"


class Product(UserString):
    """
    Product class to hold product id
    """

    def __init__(self, name: str, id: int):  # pylint: disable=redefined-builtin
        self.data = name
        self.id = id
        super().__init__(name)


@total_ordering
class RPMVersion:
    """
    RPMVersion class to compare RPM versions
    """

    def __init__(self, version: str, release: str):
        self.version = version
        self.release = release
        self._tuple = ("1", version, release)

    def __str__(self):
        return f"{self.version}-{self.release}"

    def __lt__(self, other):
        # pylint: disable=no-member
        return rpm.labelCompare(self._tuple, other._tuple) < 0

    def __eq__(self, other):
        # pylint: disable=no-member
        return rpm.labelCompare(self._tuple, other._tuple) == 0


@cache
def get_data(url: str) -> list[dict]:
    """
    Get data from URL
    """
    try:
        got = session.get(url, timeout=TIMEOUT)
        got.raise_for_status()
    except RequestException as error:
        logging.error("%s: %s", url, error)
        sys.exit(1)
    return got.json()["data"]


def get_product_id(identifier: str) -> int:
    """
    Get product ID
    """
    url = "https://scc.suse.com/api/package_search/products"
    products = get_data(url)
    for product in products:
        if product["identifier"] == identifier:
            return product["id"]
    raise LookupError(f"Not found: {identifier}")


def get_products(arch: str) -> list[Product]:
    """
    Print list of products
    """
    url = "https://scc.suse.com/api/package_search/products"
    products = get_data(url)
    return sorted(
        Product(name=p["identifier"][: p["identifier"].rfind("/")], id=p["id"])
        for p in products
        if p["architecture"] == arch
    )


def print_version(
    package: str,
    regex: re.Pattern,
    product: Product,
    all_versions: bool = False,
) -> None:
    """
    Print version
    """
    url = "https://scc.suse.com/api/package_search/packages"
    query_params: dict[str, int | str] = {"product_id": product.id}
    if regex.pattern == f"{package}$" and not regex.flags & re.IGNORECASE:
        query_params["query"] = package
    url = f"{url}?{urlencode(query_params)}"
    data = get_data(url)

    latest: dict[str, RPMVersion] = {}
    for info in sorted(
        filter(lambda i: regex.match(i["name"]), data),
        key=lambda i: (i["name"], RPMVersion(i["version"], i["release"])),
    ):
        rpm_version = RPMVersion(info["version"], info["release"])
        if all_versions:
            print(product, info["name"], rpm_version)
        else:
            latest[info["name"]] = rpm_version

    if not all_versions:
        for name, rpm_version in latest.items():
            print(product, name, rpm_version)


def get_regex(
    package: str, ignore_case: bool = False, is_regex: bool = False
) -> re.Pattern:
    """
    Compile package string to regular expression
    """
    flags = re.IGNORECASE if ignore_case else 0
    if is_regex:
        return re.compile(package, flags)
    if any(c in package for c in "[?*"):
        return re.compile(fnmatch.translate(package), flags)
    return re.compile(f"{package}$", flags)


def main() -> None:
    """
    Main function
    """
    parser = argparse.ArgumentParser(
        prog="susepkg",
        description="show SUSE package versions",
    )
    parser.add_argument("-a", "--all", action="store_true", help="show all versions")
    parser.add_argument(
        "-A",
        "--arch",
        choices=["aarch64", "ppc64le", "s390x", "x86_64"],
        default=platform.machine(),
    )
    parser.add_argument(
        "-i", "--insensitive", action="store_true", help="case insensitive search"
    )
    parser.add_argument("-p", "--product", help="product or list or any")
    parser.add_argument(
        "-x", "--regex", action="store_true", help="search regular expression"
    )
    parser.add_argument("--version", action="version", version=f"v{VERSION}")
    parser.add_argument("package", nargs="?")
    args = parser.parse_args()

    if args.product == "list":
        for product in get_products(args.arch):
            print(product)
    elif not args.package:
        parser.print_help()
        sys.exit(1)
    else:
        if args.product == "any":
            products = get_products(args.arch)
        else:
            products = [
                Product(
                    name=args.product, id=get_product_id(f"{args.product}/{args.arch}")
                )
            ]
            # Pre-fetch the data and warm the cache
            url = "https://scc.suse.com/api/package_search/packages?product_id="
            with ThreadPoolExecutor() as executor:
                executor.map(get_data, [f"{url}{product.id}" for product in products])
        regex = get_regex(
            args.package, ignore_case=args.insensitive, is_regex=args.regex
        )
        for product in products:
            print_version(
                package=args.package,
                regex=regex,
                product=product,
                all_versions=args.all,
            )


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
