#!/usr/bin/env python3
"""
Show SUSE package versions
"""

import argparse
import fnmatch
import logging
import platform
import re
import os
import sys
from collections import UserString
from concurrent.futures import ThreadPoolExecutor
from datetime import timedelta
from functools import total_ordering
from urllib.parse import urlencode

import rpm  # type: ignore
from requests.exceptions import RequestException
from requests_toolbelt.utils import dump  # type: ignore

# Creates cache.sqlite
from requests_cache import CachedSession

session = CachedSession(
    "susepkg.cache",
    # Cannot use sqlite with multi-threading on Python 3.12 due to:
    # https://github.com/requests-cache/requests-cache/issues/845
    backend="filesystem" if sys.version_info.minor >= 12 else "sqlite",
    cache_control=True,
    expire_after=timedelta(days=3),
    use_cache_dir=True,
)


TIMEOUT = 60
VERSION = "0.9"


class Product(UserString):
    """
    Product class to hold product identifier
    """

    _products: list[dict] = []

    def __init__(
        self, name: str, ident: int | None = None, arch: str | None = None
    ) -> None:
        self.data = name
        self.id = ident or self._get_product_id(f"{name}/{arch}")
        super().__init__(name)

    @staticmethod
    def _get_products() -> list[dict]:
        url = "https://scc.suse.com/api/package_search/products"
        return get_data(url)

    @classmethod
    def _get_product_id(cls, identifier: str) -> int:
        """
        Get product ID
        """
        if not cls._products:
            cls._products = cls._get_products()
        for product in cls._products:
            if product["identifier"] == identifier:
                return product["id"]
        raise LookupError(f"Not found: {identifier}")

    @classmethod
    def get_products(cls, arch: str) -> list["Product"]:
        """
        Get list of products
        """
        if not cls._products:
            cls._products = cls._get_products()
        return sorted(
            cls(name=p["identifier"].removesuffix(f"/{arch}"), ident=p["id"], arch=arch)
            for p in cls._products
            if p["architecture"] == arch
        )


@total_ordering
class RPMVersion:
    """
    RPMVersion class to compare RPM versions
    """

    def __init__(self, version: str, release: str) -> None:
        self.version = version
        self.release = release
        self._tuple = ("1", version, release)

    def __str__(self) -> str:
        return f"{self.version}-{self.release}"

    def __lt__(self, other) -> bool:
        # pylint: disable=no-member
        return rpm.labelCompare(self._tuple, other._tuple) < 0

    def __eq__(self, other) -> bool:
        # pylint: disable=no-member
        return rpm.labelCompare(self._tuple, other._tuple) == 0


def debugme(got, *args, **kwargs):  # pylint: disable=unused-argument
    """
    Print requests response
    """
    got.hook_called = True
    if not getattr(got, "from_cache", False):
        print(dump.dump_all(got).decode("utf-8"), file=sys.stderr)
    return got


def get_data(url: str) -> list[dict]:
    """
    Get data from URL
    """
    try:
        got = session.get(url, timeout=TIMEOUT)
        got.raise_for_status()
    except RequestException as error:
        logging.error("%s: %s", url, error)
        raise
    return got.json()["data"]


def fetch_versions(
    product: Product, package: str, regex: re.Pattern, all_versions: bool
) -> list[str]:
    """
    Fetch package versions for a single product.
    """
    url = "https://scc.suse.com/api/package_search/packages"
    query_params: dict[str, int | str] = {"product_id": product.id}
    if regex.pattern == f"{package}$" and not regex.flags & re.IGNORECASE:
        query_params["query"] = package
    url = f"{url}?{urlencode(query_params)}"
    data = get_data(url)

    lines = []
    latest: dict[str, RPMVersion] = {}
    for info in sorted(
        filter(lambda i: regex.match(i["name"]), data),
        key=lambda i: (i["name"], RPMVersion(i["version"], i["release"])),
    ):
        rpm_version = RPMVersion(info["version"], info["release"])
        if all_versions:
            lines.append(f'{product} {info["name"]} {rpm_version}')
        else:
            latest[info["name"]] = rpm_version
    if not all_versions:
        for name, rpm_version in latest.items():
            lines.append(f"{product} {name} {rpm_version}")
    return lines


def print_version(
    package: str,
    arch: str,
    regex: re.Pattern,
    product_name: str,
    all_versions: bool = False,
) -> None:
    """
    Print version
    """
    try:
        if product_name == "any":
            products = Product.get_products(arch)
        else:
            products = [Product(name=product_name, arch=arch)]
    except RequestException:
        sys.exit(1)

    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [
            executor.submit(fetch_versions, product, package, regex, all_versions)
            for product in products
        ]
        for future in futures:
            try:
                lines = future.result()
                for line in lines:
                    print(line)
            except RequestException:
                pass
            except Exception as exc:  # pylint: disable=broad-exception-caught
                print(f"ERROR: {exc}", file=sys.stderr)


def get_regex(
    package: str, ignore_case: bool = False, regex: bool = False
) -> re.Pattern:
    """
    Compile package string to regular expression
    """
    flags = re.IGNORECASE if ignore_case else 0
    if regex:
        return re.compile(package, flags)
    if any(c in package for c in "[?*"):
        return re.compile(fnmatch.translate(package), flags)
    return re.compile(f"{package}$", flags)


def main() -> None:
    """
    Main function
    """
    parser = argparse.ArgumentParser(
        prog="susepkg",
        description="show SUSE package versions",
    )
    parser.add_argument("-a", "--all", action="store_true", help="show all versions")
    parser.add_argument(
        "-A",
        "--arch",
        choices=["aarch64", "ppc64le", "s390x", "x86_64"],
        default=platform.machine(),
    )
    parser.add_argument(
        "-i", "--insensitive", action="store_true", help="case insensitive search"
    )
    parser.add_argument("-p", "--product", help="product or list or any")
    parser.add_argument(
        "-x", "--regex", action="store_true", help="search regular expression"
    )
    parser.add_argument("--version", action="version", version=f"v{VERSION}")
    parser.add_argument("package", nargs="?")
    args = parser.parse_args()

    if args.product == "list":
        for product in Product.get_products(args.arch):
            print(product)
    elif not args.package:
        parser.print_help()
        sys.exit(1)
    else:
        regex = get_regex(args.package, ignore_case=args.insensitive, regex=args.regex)
        print_version(
            package=args.package,
            arch=args.arch,
            regex=regex,
            product_name=args.product,
            all_versions=args.all,
        )


if __name__ == "__main__":
    if os.getenv("DEBUG"):
        session.hooks["response"].append(debugme)
    logging.basicConfig(format="%(levelname)-8s %(message)s", stream=sys.stderr)
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
